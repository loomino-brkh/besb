#!/bin/bash
# Check if command argument is provided
if [ -z "$1" ]; then
    echo "Error: App name is required"
    echo "Usage: $0 <app_name> <command>"
    exit 1
fi

if [ -z "$2" ]; then
    echo "Error: Command is required"
    echo "Usage: $0 <app_name> <command>"
    exit 1
fi

APP_NAME="$1"
COMMAND="$2"

# Set up directory paths first
PROJECT_DIR="$HOME/projects/api_${APP_NAME}"
SUPPORT_DIR="${PROJECT_DIR}/support"
MAIN_DIR="${PROJECT_DIR}/main"
DJANGO_DIR="${PROJECT_DIR}/django_auth"
ROOT_DIR="$HOME/.root_dir"

# Container names
POD_NAME="${APP_NAME}_pod"
POSTGRES_CONTAINER_NAME="${APP_NAME}_postgres"
REDIS_CONTAINER_NAME="${APP_NAME}_redis"
UVICORN_CONTAINER_NAME="${APP_NAME}_uvicorn"
DJANGO_CONTAINER_NAME="${APP_NAME}_django"
NGINX_CONTAINER_NAME="${APP_NAME}_nginx"
PGADMIN_CONTAINER_NAME="${APP_NAME}_pgadmin"
CFL_TUNNEL_CONTAINER_NAME="${APP_NAME}_cfltunnel"
INTERACT_CONTAINER_NAME="${APP_NAME}_interact"

# Load environment configuration
ENV_FILE="${SUPPORT_DIR}/env.conf"
if [ ! -f "$ENV_FILE" ]; then
    echo "Creating environment configuration..."
    mkdir -p "$SUPPORT_DIR"
    cat > "$ENV_FILE" <<EOL
# Application settings
HOST_DOMAIN="api.var.my.id"
PORT1="8080"  # Nginx port
PORT2="8000"  # FastAPI port
PORT3="8001"  # Django port

# Database settings
POSTGRES_IMAGE="docker.io/library/postgres:16"
PYTHON_IMAGE="docker.io/library/python:latest"
REDIS_IMAGE="docker.io/library/redis:latest"
NGINX_IMAGE="docker.io/library/nginx:latest"
PGADMIN_IMAGE="docker.io/dpage/pgadmin4:latest"

# Path settings
ROOT_DIR="$HOME/.root_dir"
EOL
fi

# Generate secrets if not exists
if [ ! -f "${SUPPORT_DIR}/secrets.env" ]; then
    pg_user="${APP_NAME}_user"
    pg_pass=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 32)
    pg_db="${APP_NAME}_db"
    django_key=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 32)
    redis_pass=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 32)
    
    cat > "${SUPPORT_DIR}/secrets.env" <<SECRETS
# Database credentials
POSTGRES_USER=$pg_user
POSTGRES_PASSWORD=$pg_pass
POSTGRES_DB=$pg_db

# Django settings
DJANGO_SECRET_KEY=$django_key

# Redis settings
REDIS_PASSWORD=$redis_pass
SECRETS
    chmod 600 "${SUPPORT_DIR}/secrets.env"
fi

# Source environment configuration
source "$ENV_FILE"

# Load secrets
set -a
source "${SUPPORT_DIR}/secrets.env"
set +a

# Cleanup function to unset environment variables
unset_secrets() {
    unset POSTGRES_USER POSTGRES_PASSWORD POSTGRES_DB DJANGO_SECRET_KEY REDIS_PASSWORD
}
trap unset_secrets EXIT

# Check if podman is installed
if ! command -v podman &> /dev/null; then
    echo "Error: podman is not installed"
    exit 1
fi

REQUIREMENTS_FILE="${SUPPORT_DIR}/requirements.txt"
MAIN_FILE="${MAIN_DIR}/main.py"
DB_FILE="${MAIN_DIR}/db.py"
SCHEMAS_FILE="${MAIN_DIR}/schemas.py"

rev() {
  echo "Creating Python virtual environment and installing requirements..."
  podman run --rm -v "$PROJECT_DIR:/app:z" -v "$ROOT_DIR:/root:z" "$PYTHON_IMAGE" bash -c "
    apt-get update && \
    apt-get install -y curl build-essential && \
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y && \
    . \$HOME/.cargo/env && \
    python -m venv /app/support/venv && \
    source /app/support/venv/bin/activate && \
    pip install --upgrade pip && \
    pip install -r /app/support/requirements.txt"
}

init() {}
stop() {
  echo "Stopping and removing pod..."
  podman pod stop "$POD_NAME" || true
  podman pod rm "$POD_NAME" || true
}

run_postgres() {
  echo "Starting PostgreSQL container..."
  podman run -d --pod "$POD_NAME" --name "$POSTGRES_CONTAINER_NAME" \
    -e POSTGRES_DB="$POSTGRES_DB" \
    -e POSTGRES_USER="$POSTGRES_USER" \
    -e POSTGRES_PASSWORD="$POSTGRES_PASSWORD" \
    -v "$SUPPORT_DIR/db_data:/var/lib/postgresql/data:z" \
    "$POSTGRES_IMAGE"
}

wait_for_postgres() {
  echo "Waiting for PostgreSQL to be ready..."
  for i in {1..30}; do
    if podman exec -it "$POSTGRES_CONTAINER_NAME" pg_isready -U "$POSTGRES_USER" &>/dev/null; then
      echo "PostgreSQL is ready."
      return 0
    fi
    echo "Waiting for PostgreSQL... ($i/30)"
    sleep 2
  done
  echo "PostgreSQL did not become ready in time."
  return 1
}

run_redis() {
  echo "Starting Redis container..."
  podman run -d --pod "$POD_NAME" --name "$REDIS_CONTAINER_NAME" \
    -v "$SUPPORT_DIR/redis_data:/data:z" \
    "$REDIS_IMAGE" --loglevel warning
}

run_nginx() {
  echo "Starting Nginx container..."
  podman run -d --pod "$POD_NAME" --name "$NGINX_CONTAINER_NAME" \
    -v "$SUPPORT_DIR/nginx.conf:/etc/nginx/conf.d/default.conf:ro" \
    -v "$DJANGO_DIR/static:/www/django_auth/staticfiles:ro" \
    "$NGINX_IMAGE"
}

run_cfl_tunnel() {
  if [ ! -s "$SUPPORT_DIR/token" ]; then
    echo "Error: Cloudflare tunnel token is empty. Please add your token to $SUPPORT_DIR/token"
    return 1
  fi

  echo "Starting Cloudflare tunnel..."
  podman run -d --pod "$POD_NAME" --name "$CFL_TUNNEL_CONTAINER_NAME" \
    docker.io/cloudflare/cloudflared:latest tunnel --no-autoupdate run \
    --token $(cat "$SUPPORT_DIR/token")
}

run_uvicorn() {
  echo "Starting Uvicorn container..."
  podman run -d --pod "$POD_NAME" --name "$UVICORN_CONTAINER_NAME" \
    -v "$PROJECT_DIR:/app:z" \
    -e "POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME" \
    -e "REDIS_CONTAINER_NAME=$REDIS_CONTAINER_NAME" \
    -e "DJANGO_CONTAINER_NAME=$DJANGO_CONTAINER_NAME" \
    -e "POSTGRES_USER=$POSTGRES_USER" \
    -e "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" \
    -e "POSTGRES_DB=$POSTGRES_DB" \
    -e "DJANGO_SECRET_KEY=$RANDOM_KEY" \
    -w /app \
    "$PYTHON_IMAGE" ./support/uvicorn.sh
}

run_interact() {
  echo "Starting interactive container..."
  podman run -d --pod "$POD_NAME" --name "$INTERACT_CONTAINER_NAME" \
    -v "$ROOT_DIR:/root:z" \
    -v "$PROJECT_DIR:/app:z" \
    -e "POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME" \
    -e "REDIS_CONTAINER_NAME=$REDIS_CONTAINER_NAME" \
    -e "DJANGO_CONTAINER_NAME=$DJANGO_CONTAINER_NAME" \
    -e "POSTGRES_USER=$POSTGRES_USER" \
    -e "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" \
    -e "POSTGRES_DB=$POSTGRES_DB" \
    -e "DJANGO_SECRET_KEY=$DJANGO_SECRET_KEY" \
    -w /app \
    "$PYTHON_IMAGE" bash -c "sleep infinity"
}

run_cmd() {
  echo "Executing command in interactive container..."
  if ! podman container exists "$INTERACT_CONTAINER_NAME" || [ "$(podman container inspect -f '{{.State.Running}}' "$INTERACT_CONTAINER_NAME")" != "true" ]; then
    echo "Interactive container is not running. Please start the services first."
    return 1
  fi

  # Execute command without suppressing output
  podman exec -i "$INTERACT_CONTAINER_NAME" bash -c "
    source /app/support/venv/bin/activate
    set -x  # Print commands being executed
    $*
    set +x  # Turn off command printing"
}

pg() {
  echo "Starting pgAdmin container..."
  podman run -d --rm --pod "$POD_NAME" --name "$PGADMIN_CONTAINER_NAME" \
    -e "PGADMIN_DEFAULT_EMAIL=dyka@brkh.work" \
    -e "PGADMIN_DEFAULT_PASSWORD=SuperSecret" \
    -e "PGADMIN_LISTEN_PORT=5050" \
    -v "$SUPPORT_DIR/pgadmin:/var/lib/pgadmin:z" \
    "$PGADMIN_IMAGE"
}

db() {
  echo "Running database migrations..."

  # Check if the containers are running
  if ! podman container exists "$INTERACT_CONTAINER_NAME" || [ "$(podman container inspect -f '{{.State.Running}}' "$INTERACT_CONTAINER_NAME")" != "true" ]; then
    echo "Interactive container is not running. Please start the services first."
    return 1
  fi

  if ! podman container exists "$POSTGRES_CONTAINER_NAME" || [ "$(podman container inspect -f '{{.State.Running}}' "$POSTGRES_CONTAINER_NAME")" != "true" ]; then
    echo "PostgreSQL container is not running. Please start the services first."
    return 1
  fi

  # Wait for PostgreSQL to be ready
  echo "Checking PostgreSQL connection..."
  if ! podman exec -it "$POSTGRES_CONTAINER_NAME" pg_isready -U "$POSTGRES_USER"; then
    echo "PostgreSQL is not ready. Please check the container status."
    return 1
  fi

  # Run Django migrations
  echo "Running Django migrations..."
  podman exec -it \
    -e POSTGRES_CONTAINER_NAME="$POSTGRES_CONTAINER_NAME" \
    -e POSTGRES_USER="$POSTGRES_USER" \
    -e POSTGRES_PASSWORD="$POSTGRES_PASSWORD" \
    -e POSTGRES_DB="$POSTGRES_DB" \
    "$INTERACT_CONTAINER_NAME" bash -c "
      set -e
      echo 'Activating virtual environment...'
      source /app/support/venv/bin/activate
      cd /app/django_auth
      
      echo 'Making Django migrations...'
      python manage.py makemigrations
      
      echo 'Applying Django migrations...'
      python manage.py migrate
      
      echo 'Django migrations completed successfully.'
    " || {
      echo "Django migration failed."
      return 1
    }

  # Run FastAPI/Alembic migrations
  echo "Running FastAPI migrations..."
  podman exec -it \
    -e POSTGRES_CONTAINER_NAME="$POSTGRES_CONTAINER_NAME" \
    -e POSTGRES_USER="$POSTGRES_USER" \
    -e POSTGRES_PASSWORD="$POSTGRES_PASSWORD" \
    -e POSTGRES_DB="$POSTGRES_DB" \
    "$INTERACT_CONTAINER_NAME" bash -c "
      set -e
      echo 'Activating virtual environment...'
      source /app/support/venv/bin/activate
      cd /app/main
      
      if [ ! -d 'migrations/versions' ]; then
        echo 'Creating migrations directory...'
        mkdir -p migrations/versions
      fi
      
      echo 'Creating new Alembic migration...'
      alembic -c alembic.ini revision --autogenerate -m 'auto_migration'
      
      echo 'Upgrading database to latest version...'
      alembic -c alembic.ini upgrade head
      
      echo 'FastAPI migrations completed successfully.'
    " || {
      echo "FastAPI migration failed."
      return 1
    }

  echo "All database migrations completed successfully."
}

pod_create() {
  echo "Creating pod..."
  podman pod create --name "$POD_NAME" --network bridge
}

run_django() {
  echo "Starting Django container..."
  podman run -d --pod "$POD_NAME" --name "$DJANGO_CONTAINER_NAME" \
    -v "$PROJECT_DIR:/app:z" \
    -e "POSTGRES_CONTAINER_NAME=$POSTGRES_CONTAINER_NAME" \
    -e "POSTGRES_USER=$POSTGRES_USER" \
    -e "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" \
    -e "POSTGRES_DB=$POSTGRES_DB" \
    -w /app \
    "$PYTHON_IMAGE" ./django_auth/run.sh
}

wait_for_django() {
  echo "Waiting for Django to be ready..."
  for i in {1..60}; do
    if podman exec -it "$DJANGO_CONTAINER_NAME" curl -s http://127.0.0.1:8001/auth/login/ &>/dev/null; then
      echo "Django is ready."
      return 0
    fi
    sleep 2
  done
  echo "Django did not become ready in time."
  exit 1
}

esse() {
  run_postgres || return 1
  wait_for_postgres
  run_redis || return 1
  run_django || return 1
  wait_for_django
  run_uvicorn || return 1
  run_nginx || return 1
  run_cfl_tunnel || return 1
  run_interact || return 1
}

start() {
  pod_create
  esse
  sleep 10
  db
}

cek() {
  if podman pod exists "$POD_NAME"; then
    if [ "$(podman pod ps --filter name="$POD_NAME" --format "{{.Status}}" | awk '{print $1}')" = "Running" ]; then
      for container in "${POSTGRES_CONTAINER_NAME}" "${REDIS_CONTAINER_NAME}" "${DJANGO_CONTAINER_NAME}" "${UVICORN_CONTAINER_NAME}" "${NGINX_CONTAINER_NAME}" "${CFL_TUNNEL_CONTAINER_NAME}" "${INTERACT_CONTAINER_NAME}"; do
        if [ "$(podman ps --filter name="$container" --format "{{.Status}}" | awk '{print $1}')" != "Up" ]; then
          echo "Container $container is not running. Restarting..."
          podman start "$container" || {
            echo "Failed to restart $container"
            return 1
          }
        fi
      done
      echo "All containers are running."
    else
      echo "Pod is not running. Starting pod..."
      podman pod start "$POD_NAME" || {
        echo "Failed to start pod"
        return 1
      }
    fi
  else
    echo "Pod does not exist. Creating and starting..."
    start
  fi
}

create_user() {
  # Check if pod exists and is running
  if ! podman pod exists "$POD_NAME"; then
    echo "Pod does not exist. Please start the services first using 'start' command"
    return 1
  fi

  if [ "$(podman pod ps --filter name="$POD_NAME" --format "{{.Status}}" | awk '{print $1}')" != "Running" ]; then
    echo "Pod is not running. Please start the services first using 'start' command"
    return 1
  fi

  # Check if PostgreSQL container is running and ready
  if ! podman exec -it "$POSTGRES_CONTAINER_NAME" pg_isready -U "$POSTGRES_USER" &>/dev/null; then
    echo "PostgreSQL is not ready. Attempting to restart..."
    podman restart "$POSTGRES_CONTAINER_NAME"
    
    # Wait for PostgreSQL to be ready
    for i in {1..30}; do
      if podman exec -it "$POSTGRES_CONTAINER_NAME" pg_isready -U "$POSTGRES_USER" &>/dev/null; then
        echo "PostgreSQL is now ready."
        break
      fi
      if [ "$i" -eq 30 ]; then
        echo "PostgreSQL failed to become ready. Please check the container logs:"
        podman logs "$POSTGRES_CONTAINER_NAME"
        return 1
      fi
      echo "Waiting for PostgreSQL to become ready... ($i/30)"
      sleep 2
    done
  fi

  # Ensure Django container is running and ready
  if ! podman container exists "$DJANGO_CONTAINER_NAME" || [ "$(podman container inspect -f '{{.State.Running}}' "$DJANGO_CONTAINER_NAME")" != "true" ]; then
    echo "Django container is not running. Attempting to restart..."
    podman restart "$DJANGO_CONTAINER_NAME"
    sleep 5
  fi

  # Export required environment variables
  export POSTGRES_CONTAINER_NAME="$POSTGRES_CONTAINER_NAME"
  export POSTGRES_USER="$POSTGRES_USER"
  export POSTGRES_PASSWORD="$POSTGRES_PASSWORD"
  export POSTGRES_DB="$POSTGRES_DB"

  # Use the interactive container to create a Django user with proper environment setup
  echo "Creating a new Django user..."
  podman exec -it \
    -e POSTGRES_CONTAINER_NAME="$POSTGRES_CONTAINER_NAME" \
    -e POSTGRES_USER="$POSTGRES_USER" \
    -e POSTGRES_PASSWORD="$POSTGRES_PASSWORD" \
    -e POSTGRES_DB="$POSTGRES_DB" \
    "$INTERACT_CONTAINER_NAME" bash -c "
    source /app/support/venv/bin/activate
    cd /app/django_auth
    python manage.py createsuperuser
  "
}

# Check if the command exists as a function
if [ "$(type -t "$COMMAND")" = "function" ]; then
  # Execute the command
  $COMMAND
else
  echo "Error: Unknown command '$COMMAND'"
  echo "Available commands: init, start, stop, db, pg, cek, create_user"
  exit 1
fi
